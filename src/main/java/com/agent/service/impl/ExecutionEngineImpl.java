package com.agent.service.impl;

import com.agent.exception.ApiAgentException;
import com.agent.model.*;
import com.agent.service.api.AiPlanningService;
import com.agent.service.api.ExecutionEngine;
import com.agent.service.api.StateService;
import com.fasterxml.jackson.databind.JsonNode;
import com.jayway.jsonpath.JsonPath;
import io.swagger.v3.oas.models.security.SecurityScheme;
import lombok.extern.slf4j.Slf4j;
import org.jline.reader.LineReader;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.HashMap;
import java.util.Map;

/**
 * An implementation of the {@link ExecutionEngine} that processes a pre-defined {@link ExecutionPlan}
 * step-by-step to interact with an API.
 * <p>
 * This engine's primary responsibility is to faithfully execute the instructions generated by the
 * {@link AiPlanningService}. It handles the "mechanical" aspects of making API calls, including:
 * <ul>
 *   <li>Resolving parameter values, which may involve prompting the user, using static values from the plan,
 *       or extracting data from previous API call results.</li>
 *   <li>Constructing HTTP requests with the correct method, URL, path/query parameters, and headers.</li>
 *   <li>Attaching request bodies and applying security credentials.</li>
 *   <li>Executing the HTTP call and capturing the response.</li>
 * </ul>
 * Notably, this implementation has been simplified by offloading the responsibility of intelligent
 * data generation for the `--autofill` feature to the {@link AiPlanningService}, making this class
 * a pure executor of a given plan.
 */
@Service
@Slf4j
public class ExecutionEngineImpl implements ExecutionEngine {

    private final WebClient webClient;
    private final StateService stateService;

    /**
     * Constructs the Execution Engine.
     *
     * @param webClient    The reactive WebClient used to make HTTP requests.
     * @param stateService The service used to retrieve API specifications and credentials.
     */
    public ExecutionEngineImpl(WebClient webClient, StateService stateService) {
        this.webClient = webClient;
        this.stateService = stateService;
    }

    /**
     * {@inheritDoc}
     * <p>
     * This method iterates through each {@link ExecutionStep} in the provided {@link ExecutionPlan}.
     * For each step, it resolves all required parameters, builds the HTTP request, executes it,
     * and stores the result. The results of a step can be used as input for subsequent steps.
     *
     * @param plan       The AI-generated {@link ExecutionPlan} to be executed.
     * @param alias      The alias of the API to interact with.
     * @param lineReader The JLine reader for handling interactive user input if required by the plan.
     * @param autofill   A boolean flag indicating the user's original intent. While the core autofill logic
     *                   now resides in the planning service, this flag is passed for potential context or logging.
     * @return The {@link JsonNode} result of the final step in the execution plan.
     * @throws ApiAgentException if any step of the plan fails, if a required specification is not found,
     *                           or if a step depends on a previous step that has failed.
     */
    @Override
    public JsonNode execute(ExecutionPlan plan, String alias, LineReader lineReader, boolean autofill) {
        ApiSpecification spec = stateService.getSpecification(alias);
        if (spec == null) {
            throw new ApiAgentException("No API specification found for alias: " + alias);
        }

        Map<String, JsonNode> stepResults = new HashMap<>();
        JsonNode lastResult = null;

        for (ExecutionStep step : plan.getSteps()) {
            ApiOperation operation = spec.getOperations().get(step.getOperationId());
            if (operation == null) {
                throw new ApiAgentException("Invalid plan: Operation ID '" + step.getOperationId() + "' not found.");
            }

            log.info("Executing Step {}: {}", step.getStepId(), operation.getOperationId());

            try {
                Map<String, Object> resolvedParameters = resolveParameters(step, stepResults, lineReader);

                WebClient.RequestHeadersSpec<?> requestSpec = buildRequest(operation, resolvedParameters, alias, spec);
                lastResult = requestSpec.retrieve().bodyToMono(JsonNode.class).block();
                stepResults.put(step.getStepId(), lastResult);
                log.info("Step {} successful.", step.getStepId());

            } catch (WebClientResponseException e) {
                log.error("API call for step {} failed with status {} and body: {}", step.getStepId(), e.getStatusCode(), e.getResponseBodyAsString());
                throw new ApiAgentException("Step " + step.getStepId() + " (" + operation.getOperationId() + ") failed: " + e.getStatusCode() + " " + e.getResponseBodyAsString(), e);
            } catch (Exception e) {
                log.error("An unexpected error occurred during step {}", step.getStepId(), e);
                throw new ApiAgentException("Execution failed at step " + step.getStepId() + ": " + e.getMessage(), e);
            }
        }
        return lastResult;
    }

    /**
     * Resolves the parameters for a given {@link ExecutionStep} into concrete values.
     * This method is the bridge between the abstract plan and the concrete data needed for an API call.
     * It handles three distinct sources for parameter values as defined in the plan:
     * <ul>
     *   <li>{@code USER_INPUT}: Prompts the user for input via the {@link LineReader}.</li>
     *   <li>{@code STATIC}: Uses a hardcoded value directly from the plan (this includes AI-generated request bodies).</li>
     *   <li>{@code FROM_STEP}: Extracts a value from the JSON result of a previous step using a JSONPath expression.</li>
     * </ul>
     *
     * @param step        The current execution step containing parameter definitions.
     * @param stepResults A map holding the JSON results of previously completed steps.
     * @param lineReader  The JLine reader used to capture user input when necessary.
     * @return A map where keys are parameter names and values are the resolved, concrete objects.
     * @throws ApiAgentException if a parameter depends on a non-existent or failed step, or if a JSONPath expression fails.
     */
    private Map<String, Object> resolveParameters(ExecutionStep step, Map<String, JsonNode> stepResults, LineReader lineReader) {
        Map<String, Object> resolved = new HashMap<>();
        if (step.getParameters() == null) {
            return resolved;
        }

        for (Map.Entry<String, ParameterValueSource> entry : step.getParameters().entrySet()) {
            String paramName = entry.getKey();
            ParameterValueSource source = entry.getValue();
            Object value;

            switch (source.getSource()) {
                case USER_INPUT:
                    log.debug("  Resolving param '{}' from USER_INPUT", paramName);
                    String prompt = "\u001B[36m" + "Please provide a value for '" + paramName + "': " + "\u001B[0m";
                    String input = lineReader.readLine(prompt);
                    value = input.trim();
                    break;
                case STATIC:
                    value = source.getValue();
                    log.debug("  Resolving param '{}' from STATIC value: {}", paramName, value);
                    break;
                case FROM_STEP:
                    JsonNode previousResult = stepResults.get(source.getStepId());
                    if (previousResult == null) {
                        throw new ApiAgentException("Invalid plan: Step " + step.getStepId() + " depends on a non-existent or failed step " + source.getStepId());
                    }
                    try {
                        value = JsonPath.read(previousResult.toString(), source.getJsonPath());
                        log.debug("  Resolving param '{}' from Step {} using JsonPath '{}'. Value: {}", paramName, source.getStepId(), source.getJsonPath(), value);
                    } catch (Exception e) {
                        throw new ApiAgentException("Failed to resolve parameter '" + paramName + "' using JsonPath '" + source.getJsonPath() + "'", e);
                    }
                    break;
                default:
                    throw new ApiAgentException("Unknown parameter source: " + source.getSource());
            }
            resolved.put(paramName, value);
        }
        return resolved;
    }

    /**
     * Constructs and configures a {@link WebClient.RequestHeadersSpec} for a given API operation and resolved parameters.
     * This method assembles all the necessary components of an HTTP request:
     * <ul>
     *   <li>Determines the full URI by combining the server URL with the operation path.</li>
     *   <li>Replaces path parameter placeholders (e.g., `/users/{userId}`) with resolved values.</li>
     *   <li>Appends query parameters to the URI.</li>
     *   <li>Sets the appropriate HTTP method (GET, POST, PUT, DELETE).</li>
     *   <li>Attaches the request body, either from a single `__requestBody__` parameter or by assembling it
     *       from individual parameters that match the schema.</li>
     *   <li>Applies security credentials (e.g., an API key in the header) if available.</li>
     * </ul>
     *
     * @param operation The {@link ApiOperation} defining the endpoint to be called.
     * @param params    The map of resolved parameters containing all the data for the request.
     * @param alias     The alias of the API, used to fetch the correct server URL and credentials.
     * @param spec      The full {@link ApiSpecification} for the API.
     * @return A fully configured {@link WebClient.RequestHeadersSpec} ready to be executed.
     * @throws ApiAgentException if no server URL is found in the specification or if an unsupported HTTP method is used.
     */
    private WebClient.RequestHeadersSpec<?> buildRequest(ApiOperation operation, Map<String, Object> params, String alias, ApiSpecification spec) {
        if (spec.getServerUrls() == null || spec.getServerUrls().isEmpty()) {
            throw new ApiAgentException("Cannot execute request: No server URL found in the API specification.");
        }
        String baseUri = spec.getServerUrls().getFirst();
        String finalPath = operation.getPath();

        if (operation.getParameters() != null) {
            for (ApiParameter apiParam : operation.getParameters()) {
                if ("path".equals(apiParam.getIn()) && params.containsKey(apiParam.getName())) {
                    String placeholder = "{" + apiParam.getName() + "}";
                    finalPath = finalPath.replace(placeholder, String.valueOf(params.get(apiParam.getName())));
                }
            }
        }

        UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromPath(finalPath);
        if (operation.getParameters() != null) {
            operation.getParameters().stream()
                    .filter(p -> "query".equals(p.getIn()) && params.containsKey(p.getName()))
                    .forEach(p -> uriBuilder.queryParam(p.getName(), params.get(p.getName())));
        }

        String fullUri = baseUri + uriBuilder.build().toUriString();
        log.debug("Building {} request for full URI: {}", operation.getHttpMethod().toUpperCase(), fullUri);

        WebClient.RequestBodySpec requestSpec;
        String httpMethod = operation.getHttpMethod().toUpperCase();

        requestSpec = switch (httpMethod) {
            case "GET" -> (WebClient.RequestBodySpec) webClient.get().uri(fullUri);
            case "POST" -> webClient.post().uri(fullUri);
            case "PUT" -> webClient.put().uri(fullUri);
            case "DELETE" -> (WebClient.RequestBodySpec) webClient.delete().uri(fullUri);
            default -> throw new ApiAgentException("Unsupported HTTP method: " + httpMethod);
        };

        if (params.containsKey("__requestBody__")) {
            requestSpec.bodyValue(params.get("__requestBody__"));
        } else if (operation.getRequestBodySchema() instanceof Map<?, ?> requestBodySchemaMap) {
            Map<String, Object> requestBody = new HashMap<>();
            Object rawProperties = requestBodySchemaMap.get("properties");

            if (rawProperties instanceof Map<?, ?> schemaProperties) {
                for (Object key : schemaProperties.keySet()) {
                    String paramName = (String) key;
                    if (params.containsKey(paramName)) {
                        Object rawParamSchema = schemaProperties.get(paramName);
                        if (rawParamSchema instanceof Map<?, ?> paramSchema) {
                            if ("array".equals(paramSchema.get("type")) && params.get(paramName) instanceof String) {
                                String[] items = ((String) params.get(paramName)).split(",");
                                requestBody.put(paramName, items);
                                continue;
                            }
                        }
                        requestBody.put(paramName, params.get(paramName));
                    }
                }
            }
            if (!requestBody.isEmpty()) {
                log.debug("Attaching assembled request body: {}", requestBody);
                requestSpec.bodyValue(requestBody);
            }
        }

        String credential = stateService.getCredential(alias);
        if (credential != null && operation.getSecurity() != null && !operation.getSecurity().isEmpty()) {
            operation.getSecurity().getFirst().forEach((name, scopes) -> {
                SecurityScheme scheme = spec.getSecuritySchemes().get(name);
                if (scheme != null) {
                    log.debug("Applying security scheme '{}' of type {}", name, scheme.getType());
                    if (scheme.getType() == SecurityScheme.Type.APIKEY && scheme.getIn() == SecurityScheme.In.HEADER) {
                        requestSpec.header(scheme.getName(), credential);
                    }
                }
            });
        }
        return requestSpec;
    }
}